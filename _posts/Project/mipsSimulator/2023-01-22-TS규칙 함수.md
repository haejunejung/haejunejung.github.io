---
layout: post
title: TS 규칙 README <함수>
categories: [Project_mipsSimulator]
tags: [Project_mipsSimulator]
description: TS 규칙 README <함수>
---

## `함수`

### **_(1) 매개변수는 2개 혹은 그 이하로 제한하자_**

<br>

### **_(2) 함수가 한 가지 일만 할 수 있도록 하자_**

<br>

### **_(3) 중복된 코드를 제거하자_**

<br>

### **_(4) 함수 매개변수로 플래그를 사용하지 말자_**

- 플래그를 사용하는 것은 해당 함수가 한 가지 이상의 일을 한다는 것이다. 이럴 때는 함수를 쪼개도록 하자

```typescript
// BAD
function createFile(name: string, temp: boolean) {
  if (temp) {
    fs.create(`./temp/${name}`);
  } else {
    fs.create(name);
  }
}

// GOOD
function createTempFile(name: string) {
  createFile(`./temp/${name}`);
}

function createFile(name: string) {
  fs.create(name);
}
```

<br>

### **_(5) 사이드 이펙트를 최대한 피하자_**

사이트 이펙트를 가질 필요가 있다. 예를 들면, 파일을 써야할 때와 같은 경우이다.
이런 경우네 특정 파일을 쓰기 위해 몇 개의 함수와 클래스를 만들지 말고 그것을 행하는 서비스 단 하나만 만들어라.

<br>

중요한 것은 어떠한 구조도 없이 객체 사이에 상태를 공유하거나 어떤 것에 의해서든지 변경될 수 있는 데이터 타입을 사용하거나 사이드 이펙트가 일어나는 곳을 중앙화 하지 않는 것과 같은 위험 요소를 피하는 것이다.

```typescript
// BAD
let name = "Robert C. Martin";

function toBase64() {
  name = btoa(name);
}

toBase64();

console.log(name);

// GOOD
const name = "Robert C. Martin";

function toBase64(text: string): string {
  return btoa(text);
}

const encodeName = toBase64(name);
console.log(name);
```

<br>

자바스크립트에서 원시값은 값에 의해 전달되고 객체/배열은 참조에 의해 전달된다. 예를 들어, 객체와 배열의 경우 어떤 함수가 쇼핑 장바구니 배열을 변경하는 기능을 가지고 있다면, 구매하려는 아이템이 추가됨으로써 `cart` 배열을 사용하는 다른 함수는 이 추가의 영향을 받을 수 있다.

<br>

예를 들면, 사용자가 네트워크 요청을 생성하고 서버에 `cart` 배열을 전송하는 purchase 함수를 호출하는 "구매"버튼을 클릭한다. 네트워크 불량 때문에 `purchase` 함수는 요청을 재시도해야 한다. 네트워크 요청이 시작되기 전에 사용자가 원하지 않는 아이템을 실수로 장바구니에 추가하기 버튼을 누르면 어떻게 될까요?
네트워크 요청이 시작되면, `purchase` 함수는 `addItemToCart` 함수가 변경한 쇼핑 장바구니 배열을 참조하고 있기 대문에 purchase 함수는 실수로 추가된 아이템을 보낼 것입니다.

<br>

훌륭한 해법은 `addItemToCart` 함수에서 `cart` 배열을 복제하고 그것을 수정하고 그 복제한 값을 반환하는 것입니다. 이는 쇼핑 장바구니 배열을 참조하고 있는 값을 들고 있는 어떤 다른 함수도 다른 변경에 의해 영향을 받지 않는 것을 보장합니다.

- 💡 큰 객체를 복제하는 것은 성능 관점에서 비용을 높일 수 있다. 다행히도 이러한 프로그래밍 접근법을 가능하게 해주는 훌륭한 라이브러리가 있기 대문에 큰 문제가 되지 않는다. 이는 수동으로 객체와 배열을 복제해주는 것만큼 메모리 집약적이지 않게 해주고 빠르게 복제해준다.

```typescript
// BAD
function addItmeToCart(cart: CartItem[], item: Item): void {
  cart.push({ item, date: Date.now() });
}

// GOOD
function addItemToCart(cart: CartItem[], item: Item): CartItem[] {
  return [...cart, { item, date: Date.now() }];
}
```

<br>

### **_(6) 전역 함수를 작성하지 말자_**

전역을 더럽히는 것은 자바스크립트에서 나쁜 관습이라한다. 왜냐하면 다른 라이브러와 충돌날 수 있고, API의 사용자는 상용에서 예외가 발생할 때까지 전혀 모르기 때문이다. 예를 들어, 자바스크립트 네이티브 배열 메소드를 확장해서 두 배열 사이의 다른 점을 보여주는 `diff` 메소드를 추가하고 싶다면 어떻게 해야할까? `Array.prototype`에 새로운 함수를 작성할 것이다. 하지만 동일한 기능을 하고 있는 다른 라이브러리와 충돌날 수 있다. 다른 라이브러리에서는 배열에서 첫 번째 요소와 마지막 요소 사이의 다름만 찾기 위해 diff 함수를 사용한다면 어떨까? 이것은 단지 클래스를 사용해서 전역 `Array`를 상속하는 것이 더 좋은 이유이다.

```typescript
// BAD
declare global {
  interface Array<T> {
    diff(other: T[]): Array<T>;
  }
}

if (!Array.prototype.diff) {
  Array.prototype.diff = function <T>(other: T[]): T[] {
    const hash = new Set(other);
    return this.filter((elem) => !hash.has(elem));
  };
}

// GOOD
class MyArray<T> extends Array<T> {
  diff(other: T[]): T[] {
    const hash = new Set(other);
    return this.filter((elem) => !hash.has(elem));
  }
}
```

<br>

### **_(7) 명령형 프로그래밍보다 함수형 프로그래밍을 지향하자_**

```typescript
// BAD
const contributions = [
  {
    name: "UNIST",
    number: 500,
  },
  {
    name: "SNU",
    number: 1,
  },
  {
    name: "KAIST",
    number: 2,
  },
];

let totalOutput = 0;

for (let i = 0; i < contributions.length; i++) {
  totalOutput += contributions[i].number;
}

// GOOD
const contributions = [
  {
    name: "UNIST",
    number: 500,
  },
  {
    name: "SNU",
    number: 1,
  },
  {
    name: "KAIST",
    number: 2,
  },
];

const totalOutput = contributions.reduce(
  (totalNumbers, output) => totalNumbers + output.number,
  0
);
```

<br>

### **_(8) 조건문 캡슐화하자_**

```typescript
// BAD
if (isGood || isEmpty) {
  // ...
}

// GOOD
function canActiveService(isGood: boolean, isEmpty: boolean): boolean {
  return isGood || isEmpty;
}

if (canActiveService(isGood, isEmpty)) {
  // ...
}
```

<br>

### **_(9) 부정 조건문을 피하자_**

```typescript
// BAD
function isEmailNotUsed(email: string): boolean {
  // ...
}

if (isEmailNotUsed(email)) {
  // ...
}

// GOOD
function isEmailUsed(email: string): boolean {
  // ...
}

if (!isEmailUsed(email)) {
  // ...
}
```

<br>

### **_(10) 타입 체킹을 피하자 ⭐️_**

타입스크립트는 자바스크립트의 엄격한 구문적 상위 집합이며 언어에 선택적인 정적 타입 검사 기능을 추가한다.
타입스크립트의 기능을 최대한 활용하는 위해 변수의 타입, 매개변수, 반환 값의 타입을 지정하도록 하면 리팩토링이 훨씬 쉬워진다.

```typescript
// BAD
function travelToTexas(vehicle: Bicycle | Car) {
  if (vehicle instanceof Bicycle) {
    vehicle.pedal(currentLocation, new Location("texas"));
  } else if (vehicle instanceof Car) {
    vehicle.drive(currentLocation, new Location("texas"));
  }
}

// GOOD
type Vehicle = Bicycle | Car;

function travelToTexas(vehicle: Vehicle) {
  vehicle.move(currentLocation, new Location("texas"));
}
```

참고 : https://738.github.io/clean-code-typescript/
