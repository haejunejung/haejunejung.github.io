---
layout: post
title: TS 규칙 README <객체와 자료구조>
categories: [Project_mipsSimulator]
tags: [Project_mipsSimulator]
description: TS 규칙 README <객체와 자료구조>
---

## `객체와 자료구조`

### **_(1) getter와 setter를 사용하자_**

타입스크립트는 getter/setter 구문을 지원한다. 행동을 캡슐화한 객체에서 데이터를 접근하기 위해
getter와 setter를 사용하는 것은 객체에서 속성을 단순히 찾는 것보다 낫다. 이유는

1. 객체 속성을 얻는 것 이상으로 무언가를 더 하고 싶을 때, 코드 안에서 관련된 모든 접근자를 찾고 변경하지 않아도 된다.
2. set을 사용할 때 검증 로직을 추가하는 것이 간단하다
3. 내부의 API를 캡슐화 할 수 있다.
4. 값을 조회하고 설정할 때 로그를 기록하고 에러를 처리하는 것이 쉽다.
5. 서버에서 객체 속성을 불러올 때 지연 로딩을 할 수 있다.

```typescript
// BAD
type BankAccount = {
  balance: number;
  // ...
};

const value = 100;
const account: BankAccount = {
  balance: 0,
  // ...
};

if (value < 0) {
  throw new Error("Cannot set negative balance.");
}

account.balance = value;

// GOOD
class BankAccount {
  private accountBalance: number = 0;

  get balance(): number {
    return this.accountBalance;
  }

  set balance(value: number) {
    if (value < 0) {
      throw new Error("Cannot set negative balance.");
    }

    this.accountBalance = value;
  }

  // ...
}

// 이제 `BankAccount`는 검증 로직을 캡슐화합니다.
// 명세가 바뀐다면, 추가적인 검증 규칙을 추가할 필요가 있습니다.
// 그 때, `setter` 구현부만 수정하면 됩니다.
// 관련있는 다른 코드는 변경할 필요가 없습니다.
const account = new BankAccount();
account.balance = 100;
```

<br>

### **_(2) private/protected 멤버를 갖는 객체를 생성하자_**

```typescript
// BAD
class Circle {
  radius: number;

  constructor(radius: number) {
    this.radius = radius;
  }

  perimeter() {
    return 2 * Math.PI * this.radius;
  }

  surface() {
    return Math.PI * this.radius * this.radius;
  }
}

// GOOD
class Circle {
  constructor(private readonly radius: number) {}

  perimeter() {
    return 2 * Math.PI * this.radius;
  }

  surface() {
    return Math.PI * this.radius * this.radius;
  }
}
```

<br>

### **_(3) 불변성을 선호하자_**

타입스크립트의 타입 시스템은 interface / class의 개별 속성을 `readonly` 로 표현할 수 있다.
이를 통해 기능적인 방식으로 작업할 수 있다. 더욱 나은 방법으로는 타입 T를 갖고 mapped types를
사용하여 모든 각 속성을 읽기 전용으로 표시하는 Readonly 내장 타입이 존재한다.

```typescript
// BAD
interface Config {
  host: string;
  port: string;
  db: string;
}

// GOOD
interface Config {
  readonly host: string;
  readonly port: string;
  readonly db: string;
}
```

<br>

배열의 경우, ReadonlyArray<T>를 사용해서 읽기 전용의 배열을 생성할 수 있다. 이것은 push()와 fill()과 같은 변경을 막는다. 하지만 값 자체를 변경하지 않는 concat(), slice()과 같은 기능은 사용할 수 있다.

```typescript
// BAD
const array: number[] = [1, 3, 5];
array = []; // 에러
array.push(100); // 배열은 변경될 것입니다.

// GOOD
const array: ReadonlyArray<number> = [1, 3, 5];
array = []; // 에러
array.push(100); // 에러
```

<br>

리터럴 값을 위해 `const assertions`를 사용할 수 있다.

```typescript
// BAD
const config = {
  hello: "world",
};
config.hello = "world"; // 값이 바뀝니다

const array = [1, 3, 5];
array[0] = 10; // 값이 바뀝니다

// 쓸 수 있는 객체가 반환됩니다
function readonlyData(value: number) {
  return { value };
}

const result = readonlyData(100);
result.value = 200; // 값이 바뀝니다

// GOOD
// 읽기 전용 객체
const config = {
  hello: "world",
} as const;
config.hello = "world"; // 에러

// 읽기 전용 배열
const array = [1, 3, 5] as const;
array[0] = 10; // 에러

// 읽기 전용 객체를 반활할 수 있습니다
function readonlyData(value: number) {
  return { value } as const;
}

const result = readonlyData(100);
result.value = 200; // 에러
```

<br>

참고 : https://738.github.io/clean-code-typescript/
