---
layout: post
title: TS 규칙 README 1편
categories: [Project_mipsSimulator]
tags: [Project_mipsSimulator]
description: TS 규칙 README 1편
---

# **_Type vs Interface_**

- `interface`는 `type`과 마찬가지로 객체의 타입의 이름을 지정하는 또 다른 방법이다.
- 예시

```typescript

interface personInterface {
    name: string;
    age: number;
}

const person1: personInterface = {
    name: 'haejune',
    age: 25,
}

type personType = {
    name: string;
    age: number;
}

const person2: personType {
    name: 'haejune',
    age: 25,
}
```

<hr>

## ❗️ 차이점

<br>

### **_(1) 확장하는 방법_**

- `interface`

```typescript
interface personInterface {
  name: string;
  age: number;
}

interface studentInterface extends personInterface {
  scholl: string;
}
```

- `type`

```typescript
type personType = {
  name: string;
  age: number;
};

type studentType = personType & {
  school: string;
};
```

<br><br>

### **_(2) 선언적 확장_**

`interface`에서 할 수 있는 대부분의 기능들은 `type`에서 가능하지만, `type`은 새로운 속성을 추가하기 위해 **_다시 같은 이름_**으로 선언할 수 없지만, `interface`는 항상 선언적 확장이 가능하다는 것이다.

```typescript
interface book {
  title: string;
}

interface book {
  contents: string[];
}

// 같은 interface 명으로 book을 다시 만든다면, 자동으로 확장이 된다

type book = {
  title: string;
};

type book = {
  contents: string[];
};

// 같은 type 명으로 book을 다시 만들 수 없다
// Error: Duplicate identifier 'book'
```

<br><br>

### **_(3) computed value의 사용_**

- `interface`는 불가능하다

```typescript
interface NameInterface {
  [key in names]: string; //error
}
```

- `type`은 가능하다

```typescript
type names = "firstName" | "lastName";

type NameTypes = {
  [key in names]: string;
};

const name: NameTypes = { firstName: "jung", lastName: "haejune" };
```

<br><br>

### **_(4) Generic type 저장 가능 여부_**

- `interface`은 저장할 수 없다.

```typescript
interface GenericInterface {
  [x: string]: number;
}

interface NormalInterface {
  x: number;
}

const normalInterface: NormalInterface = { x: 1 };
const genericInterface: GenericInterface = normalInterface; // error
```

- `type`은 저장할 수 있다.

```typescript
type GenericType = { [x: string]: number };
type NormalType = { x: number };

const normalType: NormalType = {
  x: 1,
};
const genericType: GenericType = normalType; // no error
```

<br><br>

### **_(5) 합성_**

`interface`의 경우 객체의 타입을 만들기 위한 것이고 단순 합성이 가능하다.  
반면, `type`의 경우에는 재귀적으로 순회하면서 속성을 합성하게 되는데 이 때 일부가 `never`가 나오면서 제대로 합성이 안되는 경우가 발생할 수 있다고 한다. 또한, 합성 자체에 대한 유효성을 판단하기 전에 모든 구성요소에 대한 타입을 체크하므로 컴파일 시에 상대적으로 성능이 좋지 않다고 한다.

<hr>

## **_결론_**

<br>

밑의 이유들로 `interface`를 사용하는게 더 낫지 않을까 싶다.

1. 객체를 저장하기 위한 용도로 사용하는 경우가 많다.
2. 외부에 공개할 API이다. (선언 병합 必)
3. 복잡한 타입을 다룰 일이 없을 것으로 보인다.

<br>

`interface` 사용할 때 주의할 점들

1. `선언적 합성`이 가능하더라도 가능한 적게 사용하는 방안으로 구현해야 한다.
2. interface를 사용하는 것이 의도치 않은 에러를 발생시킬 수 있으니 유의해야한다.

<hr>

참고: https://yceffort.kr/2021/03/typescript-interface-vs-type  
참고: https://medium.com/humanscape-tech/type-vs-interface-%EC%96%B8%EC%A0%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-f36499b0de50  
참고: https://jungpaeng.tistory.com/99  
참고: https://junghyunkim.tistory.com/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B813-%ED%83%80%EC%9E%85%EA%B3%BC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%95%8C%EA%B8%B0  
참고: https://all-dev-kang.tistory.com/entry/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%ED%83%80%EC%9E%85-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC
