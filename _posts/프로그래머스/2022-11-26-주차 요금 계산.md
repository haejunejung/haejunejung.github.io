---
title : 주차 요금 계산
date : 2022.11.26
categories : 프로그래머스
---

주차 요금 계산

### 프로그래머스 주차 요금 계산

- 어떻게 풀어야 할 지에 대해서는 생각하는데 오래 걸리지 않았지만, 구현하는데 꽤나 애썼던 문제
- 현재 푼 코드는 살짝 읽기 불편하고 더럽게 풀었다고 느껴져서 내일 깔끔하게 다시 풀어서 깔끔 풀이로 밑에 게시할 예정이다

### 코드 설명

- STL map을 사용한 이유는, 같은 차의번호가 한 번씩 나오기 때문에 find가 빠른 map이 유용하지 않을까? 라고 생각했다
- 또한, key를 기준으로 오름차순으로 저장되기 때문에 따로 sort를 할 필요가 없다는 장점이 있다
- 조심해야할 점은 내역이 "IN"과 "OUT"이라는 것이다 ("in"과 "out"으로 풀다가 시간날렸음🤣)
- 문제를 푼 알고리즘은 아래의 순서로 풀었다

1. records 에서 데이터를 하나씩 확인한다. 이 때, 시간과 차의번호 그리고 내역을 각각 time, car_num, info의 변수에 담는다.
2. 내역이 "IN"이라면, 차의 정보를 저장하는 Car_info에 차의번호와 시간을 저장한다
3. 내역이 "OUT"이라면, 들어온 시간과 나가는 시간의 차를 계산하여 차가 주차장에 존재했던 모든 시간을 저장하는 Cars에 저장한다
4. 이 때, Cars에 차의번호가 처음 저장된다면 삽입하고 이미 저장된 차의번호라면 주차장에 있던 시간만 추가한다
5. records를 모두 확인한 후, Car_info에 아직 데이터가 남아있다면 이 정보들을 "IN"만 되고 "OUT"이 되지 않은 상태이므로 "23:59"에 나가는 것으로 기록한다
6. Cars에 저장된 주자창에 머문 시간을 바탕으로 요금을 계산해서 정답에 추가한다

```
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <cmath>

using namespace std;
int CalTimes (string in_time, string out_time) {
    int in_hour  = stoi(in_time.substr(0, 2));
    int out_hour = stoi(out_time.substr(0, 2));
    int in_min  = stoi(in_time.substr(3, 2));
    int out_min = stoi(out_time.substr(3, 2));
    
    int time = (out_hour - in_hour) * 60 + (out_min - in_min);    
    return time;
}

int Calfee (vector <int> fees, int times) {
    
    int fee = fees[1];
    if ((times - fees[0]) <= 0) return fee;
    
    if ((times - fees[0]) % fees[2] == 0) fee += ((times - fees[0]) / fees[2]) * fees[3];
    else fee += ((times - fees[0]) / fees[2] + 1) * fees[3];
    return fee;
}

bool cmp (pair <string, int> &a, pair <string, int> &b) {
    return a.first < b.first;
}

vector<int> solution(vector<int> fees, vector<string> records) {
    vector<int> answer;
    
    map <string, int> Cars;
    map <string, string> Car_info;
    
    for (auto data : records) {
        string time = data.substr(0, 5);
        string car_num = data.substr(6, 4);
        string info = data.substr(11);
        
        if (info == "IN") Car_info.insert({car_num, time});
        else 
        {
            auto car = Car_info.find(car_num);
            string in_time  = car->second;
            string out_time = time;
            int times = CalTimes (in_time, out_time);

            auto data = Cars.find(car_num);
            if (data == Cars.end()) Cars.insert({car_num, times});
            else data->second += times;
            
            Car_info.erase(car_num);
        }
    }
    
    while (!Car_info.empty()) {
        string car_num = Car_info.begin()->first;
        string in_time = Car_info.begin()->second;
        string out_time = "23:59";
        
        int times = CalTimes (in_time, out_time);
        
        auto data = Cars.find(car_num);
        if (data == Cars.end()) Cars.insert({car_num, times});
        else data->second += times;
        
        Car_info.erase(car_num);
    }
    
    for (auto data : Cars) {
        cout << data.second << endl;
        int fee = Calfee (fees, data.second);
        answer.push_back(fee);
    }
    
    return answer;
}
```

구현이 조금 더 깔끔하게 짤 수 있을 것 같아서 내일 다른 사람들이 푼 풀이도 보면서 다시 짜보려 한다.      
최근 들어 중요하다고 생각드는 것이 다른 사람들의 코드를 많이 보면서 좋은 코드를 기억하려고 노력할 필요가 있다는 것이다.     
PS를 혼자 하다보니 다른 사람들의 코드를 보지 않고 해결하려는 습관이 있는데, 해결한 후에는 다른 사람들의 코드를 통해 성장해야할 것 같다.   
PS를 같이 공부할 사람이 있으면 좋겠지만 다들 학교 생활하는 것도 바쁘고 과제하는 것도 바쁘다보니 선뜻 같이 할 사람을 찾기가 어려운 것 같다 :(    
그래도 컴공에 전과를 하고 프로그래밍 언어를 접하면서 많은 시간이 지나지 않았지만 많이 성장하고 있는 것을 눈으로 볼 수 있는 것이 PS의 장점인 것 같다 :)      
마치 점수를 쌓아가는 과정이 게임 속의 캐릭터를 키우는 과정 같달까... 눈으로 보이니까!       
앞으로도 꾸준히 PS를 하는 습관을 들이자!    
밑의 풀이는 더 깔끔한 코드이다 (2차 시도)