---
layout: post
title: 백준 2294 동전 2
categories: [PS, 백준]
tags: [PS, 백준]
description: 백준 2294 동전 2
---

**_백준 2294 동전 2_**

<hr>

## **_문제 설명_**

`n가지 종류의 동전`이 있다. 이 동전들을 사용해서 `가치의 합이 k원`이 되도록 하고 싶다.  
그러면서 동전의 개수가 최소가 되도록 만드려고 한다. 이 때, 각각의 동전은 몇 개라도 사용할 수 있다.  
사용한 동전의 구성이 같은데 순서만 다른 것은 같은 경우로 간주한다.

## **_해결 전략_**

`다이나믹 프로그래밍`의 전형적인 문제이다.

다이나믹 프로그래밍을 만족하기 위해서 2가지가 충족되어야 한다.

1. 큰 문제를 작은 문제로 쪼개어도 같은 문제여야 한다.
2. 작은 문제를 이용하여 큰 문제를 풀 때, 최적의 결과를 낼 수 있어야 한다.

문제의 예제 입력을 보면, 3개의 동전과 15원의 합을 만들고 싶다. 이 때, 동전은 1원, 5원, 12원이 있다.  
동전 1원만을 사용해서 15원을 만들기 위해 필요한 동전의 수는 아래와 같다.

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |

동전 1원과 5원을 사용하여 필요한 동전의 수는, 위에서 구한 동전의 수를 이용하여 구할 수 있다.

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 4   | 1   | 2   | 3   | 4   | 5   | 2   | 3   | 4   | 5   | 6   | 3   |

또, 그 다음에 12원짜리도 이용한다면, 최종적으로 1~k원을 만들 수 있는 최소의 개수들을 알 수 있다.

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 4   | 1   | 2   | 3   | 4   | 5   | 2   | 3   | 1   | 2   | 3   | 3   |

이를 통해, 점화식을 구하면, 현재 사용하는 동전은 coin이라고 하고, 구하고 있는 금액을 value라고 했을 때,  
dp[value] = min(dp[value], dp[value-coin] + 1)이 된다. 이유는,

1. 기존에 사용하는 동전의 개수가 최소일 수 있다.
2. 구하고 있는 금액(value)에서 사용하고 있는 동전(coin)의 금액을 뺀 값을 구하는 최소 개수 + coin 한 개 추가 사용할 때 최소가 될 수 있다.

## **_추가 고려사항_**

DP를 이용하였을 때, 시간복잡도는 O(nk)이다.  
coin들을 정렬하여 문제를 풀었는데, coin이 작은 것부터 계산하면 변화를 직관적으로 볼 수 있다는 장점이 있다.

<hr>

## **_코드_**

C++

```c++
#include <iostream>
#include <algorithm>

using namespace std;

void IO()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
}

int main()
{
    IO();

    int n, k;
    cin >> n >> k;

    int coin[101] = {};
    int dp[10001] = {};

    for (int i = 1; i <= n; ++i)
        cin >> coin[i];

    sort(coin, coin + n);
    fill_n(dp + 1, 10000, 10001);

    for (int i = 1; i <= n; ++i)
    {
        for (int j = coin[i]; j <= k; ++j)
        {
            dp[j] = min(dp[j], dp[j - coin[i]] + 1);
        }
    }

    if (dp[k] == 10001)
        cout << -1;
    else
        cout << dp[k];

    return 0;
}
```

Python

```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())

coins = []
for _ in range(n):
    coins.append(int(input().rstrip()))

coins.sort()
dp = [0] + [10001] * 10000

for coin in coins:
    val = coin
    while val <= k:
        dp[val] = min(dp[val], dp[val - coin] + 1)
        val += 1

if dp[k] == 10001:
    print(-1)
else:
    print(dp[k])
```
