---
layout : post
title : 최대공약수 GCD와 최소공배수 LCM [Algorithm]
date : 2022.11.01
categories : Algorithm C++
---

최대공약수와 최소공배수를 효율적으로 구하는 알고리즘

# GCD (Greatest Common Divisor)

- 최대공약수는 두 수의 공약수 중 가장 큰 공약수를 말한다
- 첫 번째 방법은 1부터 두 수 중 작은 수까지 두 수를 모두 나누어봤을 때, 두 나머지가 0이 되는 수 중 가장 큰 수를 찾는 것이다
- 첫 번째 방법은 1부터 n(작은 수)까지 모두 한 번씩 거쳐야 하기 때문에 O(n)의 시간 복잡도를 가진다
- 조금 더 효율적인 방법으로 유클리드 호제법 (Euclidean Algorithm)을 사용할 수 있다
- 유클리드 호제법을 사용하면 O(logn)의 시간 복잡도를 가진다

### 유클리드 호제법
2개의 자연수 a,b에 대해서 a를 b로 나눈 나머지를 r이라 하면 (단, a>b),   
a와 b의 최대공약수는 b와 r의 최대공약수와 같다    

```
/* C++ GCD function */
int GCD (int a, int b) {
    if (b == 0) return a;
    else return GCD(b, a%b);
}
```

# LCM (Least Common Multiple)

- 최소공배수는 두 수의 공배수 중 가장 작은 공배수를 말한다
- 첫 번째 방법으로는 두 수 중 큰 값으로부터 1씩 더해가면서 두 수를 모두 나누어봤을 때, 두 나머지가 0이 되는 수 중 가장 작은 수를 찾는다
- 어떤 수가 최소공배수가 될 지 모르고 엄청 큰 수가 최소공배수가 될 수 있기 때문에 효율적인 방법이 필요하다
- 그 효율적인 방법으로 사용할 수 있는 것이 GCD이다
- 두 수 a,b의 최소공배수는 (a * b) / gcd로 구할 수 있다

```
int LCM (int a, int b) {
    return (a*b) / GCD(a,b);
} 
```

# 모든 약수를 구하고 싶다면 ?

- 어떤 수 N 의 모든 약수들을 구하고 싶을 때 사용할 수 있는 알고리즘이 있다
- 첫 번째로는 N로부터 1까지 나머지가 0이 되는 수를 찾는 방법이다
- 이 방법은 O(n)의 시간복잡도를 가진다
- 더 효율적인 방법은 N의 제곱근까지 수를 확인하여 구하는 방법이다
- 제곱근까지 구하는 이유는 그 이후의 수는 중복되기 때문이다
- 예를 들면, 100의 제곱근은 10이고 공약수는 1,2,5,10,20,50,100인데 제곱근을 기준으로 왼쪽과 오른쪽의 곱이 대칭되는 것을 볼 수 있다
- 1 * 100 = 2 * 50 = 5 * 10 = 10 * 10으로 말이다
- 그렇기 때문에 제곱근까지 약수를 찾은 후, N에서 약수(제곱근보다 작은 수)를 나눈 수 또한 약수(제곱근보다 큰 수)가 된다

```
/* 최대공약수의 약수들을 구한다고 생각해보자 */
for (int i = 1; i*i <= GCD; i++) {
    if (GCD % i == 0) {
        /* 나머지가 0인 수 => 약수 */
        divisor.push_back(i); 
        /* i가 약수이므로 i * (GCD/i) = GCD를 만족한다. 즉, (GCD/i)도 약수이다 */
        divisor.push_back(GCD/i); 
    }
}
```

백준 2981 검문 문제에서 이 알고리즘들을 사용해볼 수 있다    
GCD의 경우 자주 사용될 수 있는 알고리즘이므로 외워두는 것이 좋을 것 같다    
아직 배울게 많은 걸 다시 한 번 느낀다:)
