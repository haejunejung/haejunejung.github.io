---
title : DB#14-3
date : 2022.11.21
categories : 데이터베이스
---

BCNF에 대한 정리글

### BCNF

- BCNF : Boyce-Codd Normal Form
- 3NF 보다 조금 더 엄격한 제한조건을 가지기 때문에 Strong 3NF 라고도 한다
- BCNF의 장점
  - 더 이상 갱신/삭제 이상이 나오지 않는다
  - 중복성이 매우 적다
  - 본래의 테이블을 항상 재구성한다 (lossless join property)
- BCNF의 단점
  - 항상 모든 FDs를 보존하지 않는다 → 3NF는 항상 모든 FDs를 보존한다 (때때로 3NF 사용)
  - FD가 보존되면 "inappropriate" 갱신을 피할 수 있기 때문에 최대한 보존하는 것이 좋다

```
X → Y가 non-trivial FD일 때, X는 R의 superkey이다

❗️ 쉽게 풀어서 얘기하자면 "모든 결정자가 KEY인 경우 BCNF"이다
```

|Name|ID|Phone|Address|   
|---|---|---|---|   
|Alice|1234|01011110000|Ulju|   
|Alice|1234|01011112222|Ulju|
|Bob|5678|01012340000|Namgu|

- ID → Name Address
- Key: {ID, Phone}
- ID는 Name Address의 결정자이다 → ID가 같다면 Name Address도 같다 → Redundancy !
- 해당 FD는 non-trivial이면서, 결정자가 Key가 아니므로 BCNF가 아니다 → Decomposition !

<br/><br/>

### BCNF 분해

1. BCNF를 만족하지 않는 FD: X → Y를 찾는다
2. X의 클로저를 구한다
3. R을 R1과 R2로 나눈다.
   - R1은 X의 클로저의 속성을 모두 포함한다
   - R2는 X와 X의 클로저에 속하지 않는 속성을 모두 포함한다
4. 모두 BCNF에 속할 때까지 단계 1,2,3을 반복한다

<br/><br/>

### BCNF 예시

- 모든 예시는 위의 분해 순서를 따른다

<br/>

```
R(A, B, C, D)
FDs: A → B, B → C, C → D
Key: A

1. B → C 
2. {B}+ = {BCD}
3. R1(B, C, D) R2(A, B)

4. R1의 Key는 B이므로 FD: C → D
5. {C}+ = {CD}
6. R1(B, C, D) R2(A, B) R3(C, D) R4(B, C)

→ R2(A, B) R3(C, D) R4(B, C)가 최종 분해 결과이다
```

<br/>

```
R(A, B, C, D, E)
FDs: AB → C, C → D, D → E
Key: AB

1. C → D
2. {C}+ = {CDE}
3. R1(C, D, E) R2(A, B, C)

1. R1의 Key는 C이므로 FD: D → E
2. {D}+ = {DE}
3. R1(C, D, E) R2(A, B, C) R3(D, E) R4(C, D)

→ R2(A, B, C) R3(D, E) R4(C, D)가 최종 분해 결과이다
```

<br/>

```
Tricky Case of BCNF Decomposition
R(A, B, C, D, E)
FDs: A → B, BC → D
Key: ACE

1. A → B
2. {A}+ = {AB}
3. R1(A, B) R2(A, C, D, E)

1. R2에 FD: BC → D를 비교할 수 없다 (BC가 존재 X) ⇢ FD: AC → D
2. {AC}+ = {ACD}
3. R1(A, B) R2(A, C, D, E) R3(A, C, D) R4(A, C, E)

→ R1(A, B) R3(A, C, D) R4(A, C, E)가 최종 분해 결과이다
```

<br/>

```
R(A, B, C, D, E, F)
FDs: B → D, C → E, DE → A
Key: BCF

1. B → D
2. {B}+ = {BD}
3. R1(B, D) R2(A, B, C, D, E, F)

1. DE → A
2. {DE}+ = {ADE}
3. R1(B, D) R2(A, B, C, D, E, F) R3(A, D, E) R4(B, C, D, E, F)

1. C → E
2. {C}+ = {CE}
3. R1(B, D) R2(A, B, C, D, E, F) R3(A, D, E) R4(B, C, D, E, F) R5(C, E) R6(B, C, D, F)

→ R1(B, D) R3(A, D, E) R5(C, E) R6(B, C, D, F)
❗️ 모든 FDs를 나오는 것부터 확인할 필요가 없다. 
오히려 그렇게 했을 때 Tricky Case일수도 있으니 잘 생각해서 해야된다.
```
