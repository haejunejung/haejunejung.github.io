---
title : DB#14-4
date : 2022.11.22
categories : 데이터베이스
---

3NF에 대한 정리글

### 3NF

- BCNF의 완화된 버전
- 분해를 할 때, 항상 FDs를 보존한다
- 3NF의 만족 조건
  - X → Y가 non-trivial일 때
  - X가 key를 포함하는 경우
  - Y가 key에 포함되는 경우
  - Y가 X에 포함되는 경우

```
R(A, B, C)
FDs: C → B, AB → C, BC → C
Keys: {AB}, {AC}

C → B is OK, B가 key에 포함되는 경우에 속한다
AB → C is OK, AB가 key에 포함되는 경우에 속한다
BC → C is OK, C가 BC안에 포함되는 경우에 속한다
```

<br/><br/>

### 3NF 분해

- 3NF의 분해 순서는 아래와 같다

1. Minimal basis를 구한다
2. Minimal basis에서 LHS가 같은 FDs를 합친다
3. 각각의 FD를 유지하는 테이블을 생성한다
4. 만약 어느 테이블도 key를 포함하지 않는다면, key를 가진 테이블을 생성한다
5. 중복되는 테이블을 제거한다

<br/><br/>

### Minimal Basis

```
S = {A → BD, AB → C, C → D, BC → D}
```

- Minimal Basis 안의 모든 FD는 RHS에 속성이 하나이다
  - ex) A → BD는 Minimal Basis에 속할 수 없다 
- Minimal Basis 안의 어떤 FD는 다른 FD로부터 파생될 수 없다
  - ex) BC → D는 C → D로부터 파생될 수 있으므로 BC → D는 Minimal Basis에 속할 수 없다
- Minimal Basis 안의 어떤 FD는 원래 FDs로부터 파생되지 않은 새로운 FD일 수 있다
  - ex) AB → C로부터 A → C의 FD가 만들어지는데, 이것이 하나의 예시이다 (이후 설명)

<br/><br/>

### Minimal Basis 알고리즘

```
S = {A → BD, AB → C, C → D, BC → D}
```

1. RHS가 하나가 되도록 모든 FD를 바꾼다

```
S = {A → B, A → D, AB → C, C → D, BC → D}
```

2. 중복되는 FD를 제거한다

```
(1) A → B가 중복인지 check

A → B를 제거했을 때, {A}+ = {AD}이므로 A → B는 다른 FD로부터 파생되지 않는다 ⇢ Minimal Basis

(2) A → D가 중복인지 check

A → D를 제거했을 때, {A}+ = {ABCD}이므로 A → D는 다른 FD로부터 파생될 수 있다 ⇢ Not

(3) AB → C가 중복인지 check

AB → C를 제거했을 때, {AB}+ = {AB}이므로 AB → C는 다른 FD로부터 파생되지 않는다 ⇢ Minimal Basis

(4) C → D가 중복인지 check

C → D를 제거했을 때, {C}+ = {C}이므로 A → B는 다른 FD로부터 파생되지 않는다 ⇢ Minimal Basis

(5) BC → D가 중복인지 check

BC → D를 제거했을 때, {BC}+ = {BCD}이므로 A → D는 다른 FD로부터 파생될 수 있다 ⇢ Not

최종 남은 FDs = {A → B, AB → C, C → D}
```

3. 각각의 FD의 LHS의 중복되는 속성들을 제거한다

```
AB → C만이 LHS가 한 개이상의 속성을 가지고 있다 → check

(1) A가 중복되는지 check

A를 제거했을 때, B → C가 되는데 {B}+ = {B}이므로 "hidden"이 아니다 ⇢ Not

(2) B가 중복되는지 check

B를 제거했을 때, A → C가 되는데 {A}+ = {ABCD}이므로 "hidden"이다 ⇢ Minimal Basis
```

<br/><br/>

### 3NF 분해 설명

```
R(A, B, C, D)
A minimal basis {A → B, A → C, C → D}

Step 1: LHS가 같은 것들을 합친다 ⇢ {A → BC, C → D}

Step 2: 각각의 FD를 유지하는 테이블을 만든다 ⇢ R1(A, B, C) R2(C, D)

Step 3: 중복되는 테이블이 있다면 제거한다 (if any)

Tricky issue: Step2에서 만들어진 테이블들이 R의 Key를 하나도 가지지 않는다면, Key를 포함하는 테이블을 새로 만든다
```

<br/><br/>

### BCNF vs 3NF

BCNF 

- non-trivial FD의 LHS가 슈퍼키이다
- 삽입/갱신/삭제 이상을 피할 수 있다
- 대부분의 중복성을 제거한다
- 모든 FDs를 보존하지 않을 수 있다

3NF 

- non-trivial FD의 LHS가 슈퍼키이거나 RHS가 key나 LHS에 포함된다
- 삽입/갱신/삭제 이상을 피할 수 있다
- BCNF보다 중복성이 높다 (BCNF와 같은 경우도 있다)
- 모든 FDs를 보존한다

<br/><br/>

어떤 방법을 사용해야 될 지를 정하는 것은 먼저 BCNF를 해본다.    
이후, 모든 FDs를 보존하지 않는다면 3NF 방법을 사용한다.     
인터넷에 찾아봤을 때, 일반적으로 3NF로 대부분의 Case를 나눌 수 있다고 한다.     
실제 일상생활에서는 BCNF를 찾기 힘들어서 3NF로 나눈다고 하는데, 이것에 대해서는 다음에 더 찾아봐야겠다 :)


