---
layout: post
title: 가장 긴 증가하는 부분 수열2
categories: [BOJ]
tags: [BOJ]
description: BOJ 12015 가장 긴 증가하는 부분 수열2
---

# **_BOJ 12015 가장 긴 증가하는 부분 수열2_**

- `이분 탐색` 알고리즘
- 이분 탐색 알고리즘에 속하는 이유는 `lower_bound`함수가 이분 탐색을 이용하여 만들어졌기 때문이다.

<hr>

## 풀이

- 처음 입력을 받은 배열 arr 생성
- `arr[0]`를 가장 긴 증가하는 부분 수열의 결과를 넣을 `result` 배열에 넣는다. (초기 상태)

<br>

- ❗️ lower_bound를 사용하기 위해서는 항상 정렬된 상태여야 한다.
- ❗️ lower_bound를 이용하게 되면, 개수를 셀 수 있을 뿐 실제 값을 구할 수는 없다.
- result는 항상 오름차순 정렬된 상태를 유지하므로, result.back < arr[i]일 때는 push

```c++
if (result.back() < arr[i])
    result.push_back(arr[i]);
```

- result.back >= arr[i] → lower_bound를 통해 arr[i]가 들어갈 자리를 찾는다.
- 이 때, lower_bound는 index를 반환한다.
- 만약 result[1] < arr[i] < result[2] 라면, 2를 반환하게 된다.
- 해당 index위치에 arr[i]를 넣는다.

```c++
else
{
    auto it = lower_bound(result.begin(), result.end(), arr[i]);
    *it = arr[i];
}
```

<hr>

## 💡 **_Code_**

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

vector<int> arr;
int N;

void solve()
{
    vector<int> result;
    result.push_back(arr[0]);

    for (int i = 1; i < N; ++i)
    {
        if (result.back() < arr[i])
            result.push_back(arr[i]);
        else
        {
            auto it = lower_bound(result.begin(), result.end(), arr[i]);
            *it = arr[i];
        }
    }

    cout << result.size();
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> N;

    for (int i = 0; i < N; ++i)
    {
        int inp;
        cin >> inp;

        arr.push_back(inp);
    }

    solve();

    return 0;
}
```
