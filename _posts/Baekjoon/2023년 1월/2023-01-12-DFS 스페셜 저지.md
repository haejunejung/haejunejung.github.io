---
layout: post
title: DFS 스페셜 저지
categories: [BOJ]
tags: [BOJ]
description: BOJ 16964 DFS 스페셜 저지
---

# **_BOJ 16964 DFS 스페셜 저지_**

## 풀이

### 1. 양방향 그래프로 각 정점을 연결하는 간선을 만든다

```c++
for (size_t i = 0; i < N - 1; ++i)
{
    int p1, p2;
    cin >> p1 >> p2;

    graph[p1].push_back(p2);
    graph[p2].push_back(p1);
}
```

### 2. 문제에서 연결되는 순서가 입력받은 순서가 아닌 `연결될 수 있는 어떤 DFS여도 되기 때문에` 순서를 결정지어줘야한다.

```c++
for (size_t i = 1; i <= N; ++i)
{
    int p;
    cin >> p;

    res.push(p);
    order[p] = i;
}
```

### 3. ❗️ 연결되는 순서에 따라 정렬해준다.

```c++
for (size_t i = 1; i <= N; ++i)
    sort(graph[i].begin(), graph[i].end(), [](int a, int b)
            { return order[a] < order[b]; });
```

### 4. 이후 DFS를 지나면서, 연결되는 순서가 다르다면 0을 출력하고 종료한다.

- 💡 res를 queue로 만든 이유는 FIFO구조라고 생각해서 vector의 idx로 판단하는 것보다 빠를 것이라 생각했기 때문이다.

```c++
if (res.front() != x)
{
    cout << 0;
    exit(0);
}
```

### 5. 중간에 종료되는 일 없이, dfs 함수를 종료하게 되면 올바른 DFS 방문 순서이기 때문에 1을 출력하며 종료한다.

<br><br/>

## 💡 **_Code_**

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

#define MAX 100001

using namespace std;

typedef vector<int> vec;

vec graph[MAX];
queue<int> res;
int order[MAX];
bool check[MAX];

void dfs(int x)
{
    if (check[x])
        return;

    if (res.front() != x)
    {
        cout << 0;
        exit(0);
    }

    res.pop();
    check[x] = true;

    for (auto point : graph[x])
    {
        if (!check[point])
            dfs(point);
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    size_t N;
    cin >> N;

    for (size_t i = 0; i < N - 1; ++i)
    {
        int p1, p2;
        cin >> p1 >> p2;

        graph[p1].push_back(p2);
        graph[p2].push_back(p1);
    }

    for (size_t i = 1; i <= N; ++i)
    {
        int p;
        cin >> p;

        res.push(p);
        order[p] = i;
    }

    for (size_t i = 1; i <= N; ++i)
        sort(graph[i].begin(), graph[i].end(), [](int a, int b)
             { return order[a] < order[b]; });

    dfs(1);

    cout << 1;

    return 0;
}
```
