---
layout: post
title: DFS ìŠ¤í˜ì…œ ì €ì§€
categories: [BOJ]
tags: [BOJ]
description: BOJ 16964 DFS ìŠ¤í˜ì…œ ì €ì§€
---

# **_BOJ 16964 DFS ìŠ¤í˜ì…œ ì €ì§€_**

## í’€ì´

### 1. ì–‘ë°©í–¥ ê·¸ë˜í”„ë¡œ ê° ì •ì ì„ ì—°ê²°í•˜ëŠ” ê°„ì„ ì„ ë§Œë“ ë‹¤

```c++
for (size_t i = 0; i < N - 1; ++i)
{
    int p1, p2;
    cin >> p1 >> p2;

    graph[p1].push_back(p2);
    graph[p2].push_back(p1);
}
```

### 2. ë¬¸ì œì—ì„œ ì—°ê²°ë˜ëŠ” ìˆœì„œê°€ ì…ë ¥ë°›ì€ ìˆœì„œê°€ ì•„ë‹Œ `ì—°ê²°ë  ìˆ˜ ìˆëŠ” ì–´ë–¤ DFSì—¬ë„ ë˜ê¸° ë•Œë¬¸ì—` ìˆœì„œë¥¼ ê²°ì •ì§€ì–´ì¤˜ì•¼í•œë‹¤.

```c++
for (size_t i = 1; i <= N; ++i)
{
    int p;
    cin >> p;

    res.push(p);
    order[p] = i;
}
```

### 3. â—ï¸ ì—°ê²°ë˜ëŠ” ìˆœì„œì— ë”°ë¼ ì •ë ¬í•´ì¤€ë‹¤.

```c++
for (size_t i = 1; i <= N; ++i)
    sort(graph[i].begin(), graph[i].end(), [](int a, int b)
            { return order[a] < order[b]; });
```

### 4. ì´í›„ DFSë¥¼ ì§€ë‚˜ë©´ì„œ, ì—°ê²°ë˜ëŠ” ìˆœì„œê°€ ë‹¤ë¥´ë‹¤ë©´ 0ì„ ì¶œë ¥í•˜ê³  ì¢…ë£Œí•œë‹¤.

- ğŸ’¡ resë¥¼ queueë¡œ ë§Œë“  ì´ìœ ëŠ” FIFOêµ¬ì¡°ë¼ê³  ìƒê°í•´ì„œ vectorì˜ idxë¡œ íŒë‹¨í•˜ëŠ” ê²ƒë³´ë‹¤ ë¹ ë¥¼ ê²ƒì´ë¼ ìƒê°í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

```c++
if (res.front() != x)
{
    cout << 0;
    exit(0);
}
```

### 5. ì¤‘ê°„ì— ì¢…ë£Œë˜ëŠ” ì¼ ì—†ì´, dfs í•¨ìˆ˜ë¥¼ ì¢…ë£Œí•˜ê²Œ ë˜ë©´ ì˜¬ë°”ë¥¸ DFS ë°©ë¬¸ ìˆœì„œì´ê¸° ë•Œë¬¸ì— 1ì„ ì¶œë ¥í•˜ë©° ì¢…ë£Œí•œë‹¤.

<br><br/>

## ğŸ’¡ **_Code_**

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

#define MAX 100001

using namespace std;

typedef vector<int> vec;

vec graph[MAX];
queue<int> res;
int order[MAX];
bool check[MAX];

void dfs(int x)
{
    if (check[x])
        return;

    if (res.front() != x)
    {
        cout << 0;
        exit(0);
    }

    res.pop();
    check[x] = true;

    for (auto point : graph[x])
    {
        if (!check[point])
            dfs(point);
    }
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    size_t N;
    cin >> N;

    for (size_t i = 0; i < N - 1; ++i)
    {
        int p1, p2;
        cin >> p1 >> p2;

        graph[p1].push_back(p2);
        graph[p2].push_back(p1);
    }

    for (size_t i = 1; i <= N; ++i)
    {
        int p;
        cin >> p;

        res.push(p);
        order[p] = i;
    }

    for (size_t i = 1; i <= N; ++i)
        sort(graph[i].begin(), graph[i].end(), [](int a, int b)
             { return order[a] < order[b]; });

    dfs(1);

    cout << 1;

    return 0;
}
```
