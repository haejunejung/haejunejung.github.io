---
layout: post
title: 두 용액
categories: [BOJ]
tags: [BOJ]
description: BOJ 2470 두 용액
---

# **_BOJ 2470 두 용액_**

- `투 포인터` 알고리즘

<hr>

## 풀이

- 입력받은 용액을 오름차순으로 정렬한다.

```c++
sort(liquid.begin(), liquid.end(), [](ll &a, ll &b)
        { return a < b; });
```

- 처음 상태는 아래와 같다.

```c++
ll left = liquid[l];
ll right = liquid[r];
ll result = liquid[l] + liquid[r];
```

- 가장 작은 수 left, 가장 큰 수 right부터 시작해서 양 쪽에서 가운데로 모이는 `투 포인터` 알고리즘 사용
- liquid[l] + liquid[r] <= sum이면, l++
- liquid[l] + liquid[r] > sum이면, r--
- 결과값은 항상 비교 후 갱신

```c++
while (l < r) // 투 포인터
{
    ll sum = liquid[l] + liquid[r];

    if (abs(sum) < abs(result)) // 결과값 비교
    {
        result = sum;
        left = liquid[l];
        right = liquid[r];
    }

    if (sum <= 0)
        l++;
    else
        r--;
}
```

<hr>

## 💡 **_Code_**

```c++
/*
Using Binary Search (Two pointer)
*/

#include <iostream>
#include <algorithm>
#include <vector>

#define MIN_MAX -2000000000

using namespace std;

typedef long long ll;

vector<ll> liquid;

void solve(size_t l, size_t r)
{
    ll left = liquid[l];
    ll right = liquid[r];
    ll result = liquid[l] + liquid[r];

    while (l < r)
    {
        ll sum = liquid[l] + liquid[r];

        if (abs(sum) < abs(result))
        {
            result = sum;
            left = liquid[l];
            right = liquid[r];
        }

        if (sum <= 0)
            l++;
        else
            r--;
    }

    cout << left << " " << right;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    size_t N;
    cin >> N;

    for (size_t i = 0; i < N; ++i)
    {
        ll input;
        cin >> input;

        liquid.push_back(input);
    }

    sort(liquid.begin(), liquid.end(), [](ll &a, ll &b)
         { return a < b; });

    solve(0, N - 1);
    return 0;
}
```
