var store = [{
        "title": "2022.10.29",
        "excerpt":"깃허브 블로그를 쓰기 시작한 날 왜 블로그를 하게 되었나? 개발자들이 다들 Today I learn… TIL… 이렇게 말하길래 나도 써볼까해서 써본다. 솔직히 얼마나 도움이 될 지는 모르겠다. 그래도 안하는 것보다 낫지않을까? 블로그를 하면서 내가 공부했던 것들을 정리하는 시간을 가질 수 있지 않을까? 라는 생각으로 쓰게 되었다 앞으로도 계속 풀게 될 알고리즘...","categories": ["블로그"],
        "tags": [],
        "url": "/%EB%B8%94%EB%A1%9C%EA%B7%B8/blog/",
        "teaser": null
      },{
        "title": "Merge Sort",
        "excerpt":"Merge Sort 알고리즘 정렬 알고리즘 중 시간 복잡도 O(nlongn)을 가지는 알고리즘 같은 시간 복잡도를 가지는 알고리즘으로는 Quick Sort가 있다 Quick Sort에 비해 공간 복잡도를 더 많이 사용하게 된다 이미 정렬되어 있는 배열에 대해서 정렬을 하는 특정 상황에서는 다른 정렬 알고리즘이 더 빠를 수 있다 Code 재귀를 사용하여 배열에 있는 모든...","categories": ["알고리즘"],
        "tags": [],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/mergesort/",
        "teaser": null
      },{
        "title": "하노이 탑",
        "excerpt":"하노이 탑 알고리즘 하노이 탑 재귀함수를 이해할 수 있는 좋은 문제 중 하나이다 재귀를 사용하기 위해서는 Base case와 Inductive case를 잘 나눠야 한다 하노이 탑의 경우, N개의 블럭을 옮길 때 N이 1인 경우가 Base case에 해당한다 하노이 탑의 기본적인 틀은 1, 2, 3으로 움직일 수 있다고 하고, 1에 있는 N개의...","categories": ["알고리즘"],
        "tags": [],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/hanoi/",
        "teaser": null
      },{
        "title": "최대공약수 GCD와 최소공배수 LCM",
        "excerpt":"최대공약수와 최소공배수를 효율적으로 구하는 알고리즘 GCD (Greatest Common Divisor) 최대공약수는 두 수의 공약수 중 가장 큰 공약수를 말한다 첫 번째 방법은 1부터 두 수 중 작은 수까지 두 수를 모두 나누어봤을 때, 두 나머지가 0이 되는 수 중 가장 큰 수를 찾는 것이다 첫 번째 방법은 1부터 n(작은 수)까지 모두...","categories": ["알고리즘"],
        "tags": [],
        "url": "/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/GCD,LCD,CommonDivisor/",
        "teaser": null
      },{
        "title": "스도쿠",
        "excerpt":"스도쿠 백준 2580번 스도쿠 풀이 입력으로 들어오는 값들을 저장한다. 이 때, 빈칸으로 오는 곳은 따로 저장한다 빈칸을 하나씩 채워가며 모두 채웠다면 출력을 하고 종료한다 (Base Case) 이 때, return을 하는 것이 아니라 exit를 해줘야 한다. exit하지 않는다면, 다른 방법으로도 되는 경우 출력이 될 수 있기 때문이다 check 함수에서 빈 칸에...","categories": ["백준"],
        "tags": [],
        "url": "/%EB%B0%B1%EC%A4%80/sudoku/",
        "teaser": null
      },{
        "title": "가장 긴 바이토닉 부분 수열",
        "excerpt":"가장 긴 바이토닉 부분 수열 백준 11054번 가장 긴 바이토닉 부분 수열 풀이 처음에는 문제를 잘못 이해해서, 바이토닉 부분 수열이 끊기지 않고 연결되야 하는 것으로 생각했다. 문제의 밑에 힌트를 보고 꼭 연결되지 않아도 바이토닉 부분 수열을 만족하기만 하면 된다는 것을 알게 되었다. 풀이 방법은, dp를 모두 1로 초기화시킨다. (최소 길이가...","categories": ["백준"],
        "tags": [],
        "url": "/%EB%B0%B1%EC%A4%80/%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EB%B0%94%EC%9D%B4%ED%86%A0%EB%8B%89-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4/",
        "teaser": null
      },{
        "title": "Maximum vs Maximal",
        "excerpt":"Maximum과 Maximal의 차이점 Maximum (Minimum) 우리가 고려하는 것 중에서 가장 많은 것을 의미한다 MaxiMal (Minimal) Maximal이라는 단어의 앞에는 ‘inclusion-wise’가 생략되어 있다 즉, 포함 관계에 따라 최대인 것을 의미한다 Property Maximum인 것은 Maximal이기도 하다 하지만 Maximal인 것은 Maximum하다고 할 수 없다 (동일하지 않을 때가 존재한다) 정의에 의해 Maximum을 이루는 것들의 크기...","categories": ["추가공부자료"],
        "tags": [],
        "url": "/%EC%B6%94%EA%B0%80%EA%B3%B5%EB%B6%80%EC%9E%90%EB%A3%8C/maximal&maximum/",
        "teaser": null
      },{
        "title": "전깃줄",
        "excerpt":"전깃줄 백준 2565번 전깃줄 풀이 처음에는 전깃줄의 정보를 모두 받고 연결하였을 때 교차되는 점의 개수를 구하여 가장 많이 교차되는 부분부터 삭제하는 방식을 사용하려고 하였다. 백준에 나와있는 예시 입력과 출력은 정답을 맞출 수 있었지만 결과를 틀렸다고 나왔다. 어떤 부분에서 틀렸는지 찾아보니, 교차되는 점의 개수가 같을 때 없애는 순서에 따라 결과값이 달라진다는...","categories": ["백준"],
        "tags": [],
        "url": "/%EB%B0%B1%EC%A4%80/%EC%A0%84%EA%B9%83%EC%A4%84/",
        "teaser": null
      },{
        "title": "단체사진찍기",
        "excerpt":"단체사진 찍기 프로그래머스 단체사진 찍기 8명의 캐릭터를 세운다 (dfs) 조건을 확인한다 조건을 확인했을 때 통과하면 res++ 최종 정답을 return한다 정답 코드 /* 최대한 라이브러리를 추가하지 않고 풀다보니 코드가 조금 더러운 것 같다 :( */ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector &lt;string&gt; copy_data; /* data copy */ const char...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%8B%A8%EC%B2%B4%EC%82%AC%EC%A7%84%EC%B0%8D%EA%B8%B0/",
        "teaser": null
      },{
        "title": "푸드파이터 대회",
        "excerpt":"푸드파이터 대회 프로그래머스 푸드파이터 대회 코드 정답 1 다른 사람의 풀이를 봤는데, 조금 더 간결하게 해결할 수 있겠다고 생각이 들었다 :) 다소 코드가 지저분해보일 수 있어서 코드 정답 2를 만들었다 #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string solution(vector&lt;int&gt; food) { string answer = \"\"; int i,j; for (i=1; i&lt;food.size();...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%ED%91%B8%EB%93%9C%ED%8C%8C%EC%9D%B4%ED%84%B0%EB%8C%80%ED%9A%8C/",
        "teaser": null
      },{
        "title": "2022.11.10",
        "excerpt":"2022.11.10일에 내가 한 생각 컴퓨터공학과에 전과를 한 후 1년하고도 2개월이 지난 지금 드는 생각에 대해 정리해보려 한다. 나중에 이걸 읽게 되었을 때, 내가 많이 성장해있구나 라는걸 느끼고 싶어서 가끔씩 이렇게 블로그를 남기려 한다. 1년간 많은 걸 배웠고, 스스로도 공부를 나름 열심히 했다고 생각한다. 하지만, 아직 남들보다 부족하고 더 많이 노력해야...","categories": ["블로그"],
        "tags": [],
        "url": "/%EB%B8%94%EB%A1%9C%EA%B7%B8/blog/",
        "teaser": null
      },{
        "title": "우박수열 정적분",
        "excerpt":"우박수열 정적분 프로그래머스 우박수열 정적분 어렵지 않게 풀 수 있었던 문제였다. 주의해야 할 점은 b의 좌표가 0일 때가 마지막 점이라는 것이다. 처음에 풀 때에는 b가 파이썬의 인덱싱을 하듯 -1이 마지막 점이라고 생각하고 풀었다가 틀렸다. 다시 보니, 0일 때가 마지막이라는 것을 알 수 있었다. struct를 이용하여 x,y를 한 번에 넣을 수...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%9A%B0%EB%B0%95%EC%88%98%EC%97%B4-%EC%A0%95%EC%A0%81%EB%B6%84/",
        "teaser": null
      },{
        "title": "햄버거 만들기",
        "excerpt":"햄버거 만들기 프로그래머스 햄버거 만들기 간단한 문제인 햄버거 만들기였다. 중요한 점은 1 2 3 1이 순서대로 나왔을 때만 제거해야한다는 점이다. 순서대로 들어온다고 들어오는 족족 제거하게 되면 1차 시도했던 것처럼 틀리게 된다 :( #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(vector&lt;int&gt; ingredient) { int answer = 0; vector &lt;int&gt; input;...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%ED%96%84%EB%B2%84%EA%B1%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "야간 전술 보행",
        "excerpt":"야간 전술 보행 프로그래머스 야간 전술 보행 modulo 연산을 이용하는게 핵심이라고 생각한다. 그리고, scope에서 첫 번째로 나오는게 두 번째보다 작을 수 있다. 즉, start와 end가 순서대로 나오는 것이 아닌 것을 잘 확인해야한다. 제대로 확인하지 않고 풀어서 70%가량에서 정답이 안됐다:( 풀이 방법은, start와 end 사이에 온다면, times를 확인한다. times의 쉬는 시간과...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%95%BC%EA%B0%84-%EC%A0%84%EC%88%A0-%EB%B3%B4%ED%96%89/",
        "teaser": null
      },{
        "title": "옹알이 (2)",
        "excerpt":"야간 전술 보행 프로그래머스 옹알이 (2) 해당 data의 길이를 확인한 후, 4개의 word 중 하나인지 확인 만약 word가 맞다면, 이전에 같은 word가 반복되는지 확인 반복문을 통해 끝까지 돌아간다면, answer++ 중요한 건, data의 길이를 파악하는 것과 연속적인 word가 들어갈 수 없다는 점이다. data의 길이를 파악하지 않고 확인하게 되면 존재하지 않는 곳의...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%98%B9%EC%95%8C%EC%9D%B4(2)/",
        "teaser": null
      },{
        "title": "콜라 문제",
        "excerpt":"콜라 문제 콜라 문제 크게 어렵지는 않았지만 if (remainder == n) break; 이 부분에서 계속 틀렸었다. remainder가 n과 같은 경우, 무한 루프를 돌게 되서 오답이 나왔다. 조금 더 간결하게 해결해나갈 필요가 있다고 생각이 들었고 다른 사람의 풀이를 보고 밑에 간결한 풀이로도 풀어봤다. 밑의 풀이는, 몫과 나머지를 구한다. 나머지가 n과 같다면...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%BD%9C%EB%9D%BC-%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "롤케이크 자르기",
        "excerpt":"롤케이크 자르기 프로그래머스 롤케이크 자르기 핵심은 한 쪽의 종류가 하나 줄어들 때 다른 한 쪽의 종류가 늘어난다는 사실이다. 즉, total, right 배열만 만들어도 된다. 만약 이 사실을 몰랐다면, left 배열도 만들어야 되서 공간복잡도와 시간복잡도가 늘어났을 것이다. #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(vector&lt;int&gt; topping) { int answer =...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%A1%A4%EC%BC%80%EC%9D%B4%ED%81%AC-%EC%9E%90%EB%A5%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "과일 장수",
        "excerpt":"과일 장수 프로그래머스 과일 장수 score를 내림차순으로 정렬한다. m개씩 끊어서 m번째 수 * 상자의 수를 계속 더해나가면 된다. 만약 정렬 알고리즘을 사용하지 않는다면 시간복잡도가 매우 커지기 때문에 시간초과가 나지 않을까 생각한다. #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; bool compare (int &amp;a, int &amp;b) { return a &gt; b;...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EA%B3%BC%EC%9D%BC-%EC%9E%A5%EC%88%98/",
        "teaser": null
      },{
        "title": "PL#7",
        "excerpt":"PL#7 1. Reference &amp; Declaration 프로그래밍 언어에서의 변수는 두 가지 방법으로 나타낼 수 있다. 첫 번째는 변수를 선언하는 경우 (=Declaration) 두 번째는 이미 존재하는 변수를 사용하는 경우 (=Reference) 특히, 이미 존재하는 변수를 사용하는 경우에는 변수가 어디에 선언되어 있는지에 따라 값이 변화할 수 있다. 이 떄, 같은 변수가 여러 번 선언될...","categories": ["프로그래밍언어"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4/PL-7/",
        "teaser": null
      },{
        "title": "숫자 카드 만들기",
        "excerpt":"숫자 카드 만들기 프로그래머스 숫자 카드 만들기 얼마전에 공부했던 GCD를 이용해서 풀었다. 철수의 가진 모든 카드들로 나누어지면서 가장 큰 경우가 GCD이기 때문이다. 철수의 GCD를 구한다. 영희의 GCD를 구한다. 영희의 모든 카드들과 철수의 GCD와 modulo 연산을 한다. modulo 연산 결과 값이 0이 되면 조건을 만족하지 않으므로 (1)의 결과값은 0이다 반대로 철수의...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%88%AB%EC%9E%90-%EC%B9%B4%EB%93%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "DB#14-1",
        "excerpt":"DB#14-1 DB#14-1 Functional Dependency와 Normalization에 대한 정리글 DB Design Application → ER Diagram → Table DB Design을 하면서 생길 수 있는 문제의 원인은 두 가지로 나눌 수 있다 Application → ERD 단계에서 ERD가 설계가 잘 되지 않았을 때 ERD → Table 단계에서 적절하지 않게 Table이 만들어졌을 때 두 가지 원인으로부터...","categories": ["데이터베이스"],
        "tags": [],
        "url": "/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/DB-14-1/",
        "teaser": null
      },{
        "title": "DB#14-3",
        "excerpt":"BCNF에 대한 정리글 BCNF BCNF : Boyce-Codd Normal Form 3NF 보다 조금 더 엄격한 제한조건을 가지기 때문에 Strong 3NF 라고도 한다 X → Y가 non-trivial FD일 때, X는 R의 superkey이다 ❗️ 쉽게 풀어서 얘기하자면 \"모든 결정자가 KEY인 경우 BCNF\"이다 Name ID Phone Address Alice 1234 01011110000 Ulju Alice 1234 01011112222...","categories": ["데이터베이스"],
        "tags": [],
        "url": "/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/DB-14-3/",
        "teaser": null
      },{
        "title": "삼총사",
        "excerpt":"삼총사 프로그래머스 삼총사 number의 개수가 13개로 제한되어 있기 때문에, 시간 복잡도가 낮다. O(n^3)으로 구해도 값이 크지 않기 때문에 for문으로 돌려도 된다. #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(vector&lt;int&gt; number) { int answer = 0; size_t length = number.size(); for (size_t i=0; i&lt;length-2; ++i) { for (size_t...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%82%BC%EC%B4%9D%EC%82%AC/",
        "teaser": null
      },{
        "title": "DB#14-2",
        "excerpt":"DB#14-2 DB#14-2 Normal Forms에 대한 정리글 클로저를 통해 찾은 기본키들을 이용하여 테이블이 Good or not 확인하기 Type of Key Superkeys A set of attributes in a table that decides all other attributes 즉, 몇몇의 속성들이 모여서 table 안의 모든 속성들을 결정지을 수 있어야 한다 Keys Superykey 중, minimal한 상태를 말한다...","categories": ["데이터베이스"],
        "tags": [],
        "url": "/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/DB-14-2/",
        "teaser": null
      },{
        "title": "택배 상자",
        "excerpt":"택배 상자 프로그래머스 택배 상자 1~n까지 차례로 증가할 때, 처리하는 방법을 나눠서 생각하면 된다. 첫 번째로, 현재 order의 값과 같다면 answer++ 두 번째로, 현재 order의 값보다 크다면, 값이 똑같아질 때까지 sub_container에 넣은 후 answer++ 마지막으로, 현재 orderd의 값보다 작다면, sub_container의 맨 앞에 있는 것과 같은지 확인한다. 같다면, sub_container의 맨 앞을...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%ED%83%9D%EB%B0%B0%EC%83%81%EC%9E%90/",
        "teaser": null
      },{
        "title": "연속 부분 수열 합의 개수",
        "excerpt":"연속 부분 수열 합의 개수 프로그래머스 연속 부분 수열 합의 개수 작년 데이터 구조를 배우면서 원형 큐를 구현했었던 적이 있었는데, 그 때 modulo 계산을 해봤던 적이 있어 어렵지 않게 해결할 수 있었다. 중복을 허용하지 않으면서 저장할 수 있는 STL map을 사용하였는데, 생각해보니 트리 형태로 만들었어도 괜찮았을 것 같다. 중복이 되지...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%97%B0%EC%86%8D-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-%ED%95%A9%EC%9D%98-%EA%B0%9C%EC%88%98/",
        "teaser": null
      },{
        "title": "면접준비",
        "excerpt":"면접준비 에이스랩 인턴 면접준비 1. 지원동기 항상 궁금했던 점이 학교에서 공부하는 것이 실제로 회사에서 어떻게 쓰이는지 궁금했습니다. COOP라는 좋은 프로그램 속에서 여러 회사들을 보았고, 그 중 에이스랩에서 연구하고 있는 주제가 눈에 들어왔습니다. 에이스랩에서 연구하고 있는 주제가 눈에 들어온 이유는, 자율주행 자동차라는 주제가 컴퓨터 공학과로 오게 된 이유 중 큰 부분을...","categories": ["에이스랩"],
        "tags": [],
        "url": "/%EC%97%90%EC%9D%B4%EC%8A%A4%EB%9E%A9/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%841/",
        "teaser": null
      },{
        "title": "혼자 놀기 달인",
        "excerpt":"혼자 놀기 달인 프로그래머스 혼자 놀기 달인 중요하게 생각해야 하는 포인트는 두 번째 그룹이 될 수 있는 경우의 수가 1개 이상이 될 수 있다는 점이다. 또한, index는 0부터 시작되기 때문에 cards 안에 있는 데이터의 1을 뺀 값이 index가 된다는 점이다. 두 가지 경우만 잘 생각해서 푼다면 어렵지 않게 풀 수...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%ED%98%BC%EC%9E%90-%EB%86%80%EA%B8%B0-%EB%8B%AC%EC%9D%B8/",
        "teaser": null
      },{
        "title": "할인 행사",
        "excerpt":"할인 행사 프로그래머스 할인 행사 for문을 잘 이용한다면, 쉽게 풀어나갈 수 있는 문제였다. 첫 번째 풀이는 코드가 조금 조잡하다고 생각하여 두 번째 풀이에서 코드가 간결하게 바꿨다. 하지만 처리 속도를 봤을 때는, bool타입의 IsFind과 속도를 줄이기 위해 처음과 마지막 날짜 + 1일의 제품이 같은지만 비교하고 넘어가는 부분이 있어 풀이1이 더 빠를...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%ED%95%A0%EC%9D%B8-%ED%96%89%EC%82%AC/",
        "teaser": null
      },{
        "title": "두 큐 합 같게 만들기",
        "excerpt":"두 큐 합 같게 만들기 프로그래머스 두 큐 합 같게 만들기 생각해야 하는 상황 : 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우 모든 원소의 합 / 2인 개수가 2개가 만들어져야 한다 (1) (sum1 + sum2) % 2 == 1인 경우와 (2) answer == 2 * (queue1.size()...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%91%90-%ED%81%90-%ED%95%A9-%EA%B0%99%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "양궁 대회",
        "excerpt":"양궁 대회 프로그래머스 양궁 대회 같은 점수를 같은 수만큼 맞춰도 어피치가 점수를 가져간다 -&gt; 라이언이 점수를 더 많이 얻기 위해서는 어피치가 쏜 횟수 + 1개만큼 쏴야한다 최종 점수가 같을 경우 어피치가 우승한다 만약 라이언이 우승할 수 없는 경우 -1만 들어있는 vector를 return 라이언이 가장 큰 점수 차이로 우승할 수 있는...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%96%91%EA%B6%81-%EB%8C%80%ED%9A%8C/",
        "teaser": null
      },{
        "title": "빛의 경로 사이클",
        "excerpt":"빛의 경로 사이클 프로그래머스 빛의 경로 사이클 현재까지 푼 프로그래머스 문제 중 가장 난이도가 높았고 시간도 오래 걸렸던 문제.. 문제를 이해하는게 너무 힘들었던 문제였다 문제가 어려웠던 이유 사이클의 종료 조건을 정확하게 어떻게 설정해야할지를 몰랐다 이미 지나갔던 사이클을 반복하는 조건에 대해 명확하게 규정짓지 못했다 들어오는 방향과 나오는 방향을 설정할 때 상하좌우로만...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EB%B9%9B%EC%9D%98-%EA%B2%BD%EB%A1%9C-%EC%82%AC%EC%9D%B4%ED%81%B4/",
        "teaser": null
      },{
        "title": "주차 요금 계산",
        "excerpt":"주차 요금 계산 프로그래머스 주차 요금 계산 어떻게 풀어야 할 지에 대해서는 생각하는데 오래 걸리지 않았지만, 구현하는데 꽤나 애썼던 문제 현재 푼 코드는 살짝 읽기 불편하고 더럽게 풀었다고 느껴져서 내일 깔끔하게 다시 풀어서 깔끔 풀이로 밑에 게시할 예정이다 코드 설명 STL map을 사용한 이유는, 같은 차의번호가 한 번씩 나오기 때문에...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/%EC%A3%BC%EC%B0%A8-%EC%9A%94%EA%B8%88-%EA%B3%84%EC%82%B0/",
        "teaser": null
      },{
        "title": "k진수에서 소수 개수 구하기",
        "excerpt":"k진수에서 소수 개수 구하기 프로그래머스 k진수에서 소수 개수 구하기 문제 자체는 크게 어렵지 않았다 PS에서 중요한 알고리즘 두 개가 들어가 있는 문제였다 하나는, n을 k진수로 표현하는 알고리즘 또 다른 하나는 Prime Number을 확인하는 알고리즘이다 두 가지를 구현하니, 나머지는 조건에 맞게 구할 수 있었다 ❗️ int형으로 변환해서 할 경우 overflow가 일어날...","categories": ["프로그래머스"],
        "tags": [],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/k%EC%A7%84%EC%88%98%EC%97%90%EC%84%9C-%EC%86%8C%EC%88%98-%EA%B0%9C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      }]
